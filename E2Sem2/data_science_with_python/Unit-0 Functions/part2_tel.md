


# చాప్టర్: అడ్వాన్స్‌డ్ పైథాన్ ఫంక్షన్స్

**(ఫ్లెక్సిబుల్ ఆర్గ్యుమెంట్స్, ప్యాకింగ్, అన్‌ప్యాకింగ్ & రియల్ టైమ్ ఉపయోగాలు)**

**లక్ష్యం:** ఎంతమంది యూజర్లు వస్తారో, ఎన్ని ఇన్‌పుట్స్ ఇస్తారో తెలియనప్పుడు.. కోడ్ ఎలా రాయాలి?


-----


## 1️⃣ అసలు సమస్య ఏంటి?


C లేదా Java భాషల్లో ఫంక్షన్స్ చాలా "మూర్ఖంగా" (Rigid) ఉంటాయి:


 * ఒక ఫంక్షన్ కి 2 ఇన్‌పుట్స్ కావాలంటే, మీరు కచ్చితంగా 2 ఇవ్వాల్సిందే.
 * రేపు పొద్దున్న 3 కావాలంటే? కొత్త ఫంక్షన్ రాయాలి.


**ఇది రియల్ ప్రాజెక్టుల్లో చాలా కష్టం.**


### ఉదాహరణ: పిజ్జా ఆర్డరింగ్ సిస్టమ్


 * **Day 1:** `order_pizza(size)` -\> కేవలం పిజ్జా సైజు చాలు.
 * **Day 5:** `order_pizza(size, topping1)` -\> స్టూడెంట్స్ కి చీజ్ కావాలి.
 * **Day 7:** `order_pizza(size, t1, t2, t3, t4...)` -\> కస్టమర్లకి రకరకాల టాపూంగ్స్ కావాలి.


ఇలా ప్రతిసారి ఫంక్షన్ మార్చుకుంటూ పోతే, కోడ్ రాయడం కష్టమైపోతుంది.


**పైథాన్ పరిష్కారం:**


> *"మనం ఎన్ని ఇన్‌పుట్స్ ఇచ్చినా తీసుకునేలా ఒక ఫంక్షన్ ఉంటే ఎంత బాగుంటుంది?"*


అందుకే పైథాన్ లో `*args`, `**kwargs`, `/`, మరియు `*` వచ్చాయి. ఇవే పైథాన్ కి **ఫ్లెక్సిబిలిటీ** ని ఇస్తాయి.


-----


## 2️⃣ `*args` — ఎన్ని విలువలనైనా తీసుకోగలదు (Positional)


**(అన్-లిమిటెడ్ ఐటమ్స్ తీసుకునే బుట్ట)**


**అవసరం:** ఒక బిల్లింగ్ ఫంక్షన్ రాయాలి. అందులో 1 ఐటమ్ ఉండొచ్చు, లేదా 20 ఐటమ్స్ ఉండొచ్చు.


### ఉదాహరణ 1: పిజ్జా టాపింగ్స్


```python
def add_toppings(*args):
   # args అనేది ఒక టపుల్ (Tuple) లాగా మారుతుంది
   print("మీరు ఎంచుకున్నవి:", args)


# 1 ఐటమ్ తో పిలవడం
add_toppings("చీజ్")


# 3 ఐటమ్స్ తో పిలవడం
add_toppings("చీజ్", "కార్న్", "ఆలివ్స్")
```


**అవుట్‌పుట్:**


```text
మీరు ఎంచుకున్నవి: ('చీజ్',)
మీరు ఎంచుకున్నవి: ('చీజ్', 'కార్న్', 'ఆలివ్స్')
```


### ఉదాహరణ 2: మార్కుల టోటల్ (Sum)


```python
def total(*marks):
   return sum(marks)


print(total(10, 20, 30))  # 60
print(total(90, 80))      # 170
```


**చేసే తప్పులు:**


1. **`args` ని లిస్ట్ అనుకోవడం:** అది **టపుల్ (Tuple)**. దాన్ని మార్చలేం (`args[0] = 5` అంటే ఎర్రర్ వస్తుంది).
2. **ప్యాకింగ్ vs అన్‌ప్యాకింగ్ కన్ఫ్యూజన్:**
     * `total([10, 20])` -\> తప్పు\! ఇది ఒకే లిస్ట్ ని పంపిస్తుంది.
     * `total(*[10, 20])` -\> కరెక్ట్\! ఇది లిస్ట్ ని విడగొట్టి (Unpack) పంపిస్తుంది.


-----


## 3️⃣ `**kwargs` — ఎన్ని కీవర్డ్స్ నైనా తీసుకోగలదు (Keyword)


**(లేబుల్స్ అంటించిన సూట్‌కేస్)**


**అవసరం:** స్టూడెంట్ రిజిస్ట్రేషన్ ఫంక్షన్ రాయాలి. హాస్టల్ స్టూడెంట్ కి ఒకలా, డే స్కాలర్ కి మరొకలా ఫీల్డ్స్ ఉంటాయి.


### ఉదాహరణ 1: డైనమిక్ రిజిస్ట్రేషన్


```python
def register(**kwargs):
   # kwargs అనేది ఒక డిక్షనరీ (Dictionary) లాగా మారుతుంది
   print("స్టూడెంట్ డేటా:", kwargs)


register(name="ఉదయ్", age=22)
register(name="కిరణ్", dept="CSE", hostel="H3")
```


**అవుట్‌పుట్:**


```text
{'name': 'ఉదయ్', 'age': 22}
{'name': 'కిరణ్', 'dept': 'CSE', 'hostel': 'H3'}
```


### ఉదాహరణ 2: ఇన్వాయిస్ (Bill) ప్రింటింగ్


```python
def invoice(**details):
   for key, value in details.items():
       print(f"{key}: {value}")


invoice(id=101, amount=5000, tax=18, mode="online")
```


**చేసే తప్పులు:**


1. **పొజిషనల్ ఆర్గ్యుమెంట్స్ ఇవ్వడం:** `register("ఉదయ్")` -\> ఎర్రర్. `**kwargs` కేవలం `key=value` (పేరు=విలువ) ఫార్మాట్ నే తీసుకుంటుంది.


-----


## 4️⃣ అన్నింటినీ కలపడం (The Power Combo)


మనం అన్ని రకాలను ఒకే ఫంక్షన్ లో వాడాలంటే, ఈ **ఆర్డర్ (Order)** తప్పనిసరి:


1. Standard Positional (సాధారణవి)
2. `*args`
3. Standard Keyword
4. `**kwargs`


### ఉదాహరణ: API స్టైల్ ఫంక్షన్


```python
def make_pizza(size, *toppings, crust="thin", **extra):
   print(f"సైజు: {size}")
   print(f"టాపింగ్స్: {toppings}")
   print(f"క్రస్ట్: {crust}")
   print(f"ఎక్స్ట్రా: {extra}")


make_pizza(12, "చీజ్", "కార్న్", crust="pan", sauce="spicy", dip="garlic")
```


**పాండాస్ (Pandas)**, **మ్యాట్‌ప్లాట్‌లిబ్ (Matplotlib)** వంటి లైబ్రరీలు ఇలాగే రాస్తారు.


-----


## 5️⃣ POSITIONAL-ONLY PARAMETERS (`/`)


**(మోడరన్ పైథాన్ ఫీచర్)**


**అవసరం:** కొన్ని ఫంక్షన్స్ కి పేర్లు వాడకూడదు, కేవలం వరుస క్రమంలోనే విలువలు ఇవ్వాలి అనుకున్నప్పుడు ఇది వాడతాం.


### ఉదాహరణ: వృత్త వైశాల్యం (Area of Circle)


```python
def area(radius, /):
   return 3.14 * radius * radius


print(area(10))        # ✔ కరెక్ట్
# print(area(radius=10)) # ❌ ఎర్రర్! (పేరు వాడకూడదు)
```


-----


## 6️⃣ KEYWORD-ONLY PARAMETERS (`*`)


**(క్లారిటీ కోసం)**


**అవసరం:** కొన్ని ఆర్గ్యుమెంట్స్ కి కచ్చితంగా పేరు వాడాలి అని రూల్ పెట్టడం. ఇది కన్ఫ్యూజన్ ని తగ్గిస్తుంది.


### ఉదాహరణ: పేమెంట్


```python
def pay(amount, *, mode="online"):
   print(f"{amount} ని {mode} ద్వారా కట్టారు.")


pay(500, mode="cash")  # ✔ కరెక్ట్
# pay(500, "cash")       # ❌ ఎర్రర్! 'mode' అని కచ్చితంగా రాయాలి.
```


-----


## 7️⃣ MUTABLE vs IMMUTABLE (అతి ప్రమాదకరమైన రూల్)


###  కాన్సెప్ట్


 * **Immutable (Int, Float, Str, Tuple):** ఫంక్షన్ లోపల మార్చినా, బయట మారవు.
 * **Mutable (List, Dict, Set):** ఫంక్షన్ లోపల మార్చితే, బయట కూడా మారిపోతాయి.


### ⚠ అతి పెద్ద తప్పు: MUTABLE DEFAULT ARGUMENTS


బిగినర్స్ చేసే నంబర్ 1 తప్పు ఇదే.


**తప్పు పద్ధతి:**


```python
def add(item, bucket=[]):  # ఆ లిస్ట్ ఒక్కసారే క్రియేట్ అవుతుంది, అందరూ దాన్నే వాడతారు
   bucket.append(item)
   return bucket


print(add("యాపిల్"))  # ['యాపిల్']
print(add("బనానా")) # ['యాపిల్', 'బనానా'] -> అయ్యో! పాత యాపిల్ కూడా వచ్చింది!
```


**✔ సరైన పద్ధతి:**


```python
def add(item, bucket=None):
   if bucket is None:
       bucket = []  # ప్రతిసారీ కొత్త లిస్ట్ క్రియేట్ అవుతుంది
   bucket.append(item)
   return bucket
```


-----


##  ఫైనల్ సారాంశం (Cheat Sheet)


| సింబల్ | పేరు | ఉపయోగం | ఉదాహరణ |
| :--- | :--- | :--- | :--- |
| `*args` | ఆర్బిట్రరీ ఆర్గ్యుమెంట్స్ | ఎన్ని విలువలనైనా (Positional) తీసుకుంటుంది | `sum(*numbers)` |
| `**kwargs` | ఆర్బిట్రరీ కీవర్డ్స్ | ఎన్ని కీ-వాల్యూ జంటలనైనా తీసుకుంటుంది | `register(**data)` |
| `/` | పొజిషనల్-ఓన్లీ | దీనికి ముందు ఉన్నవాటిని పేరుతో పిలవకూడదు | `area(10, /)` |
| `*` | కీవర్డ్-ఓన్లీ | దీని తర్వాత ఉన్నవాటిని కచ్చితంగా పేరుతోనే పిలవాలి | `sort(data, *, reverse=True)` |
| `*` (Call) | అన్‌ప్యాకింగ్ | లిస్ట్/టపుల్ ని విడగొట్టి పంపుతుంది | `func(*list)` |
| `**` (Call) | అన్‌ప్యాకింగ్ | డిక్షనరీ ని విడగొట్టి పంపుతుంది | `func(**dict)` |


-----


##  ముగింపు (Wrap-Up)


ఈ చాప్టర్ పైథాన్ యొక్క **ఫ్లెక్సిబిలిటీ** కి గుండెకాయ లాంటిది.
సాధారణ ప్రోగ్రామర్ కి, ప్రొఫెషనల్ కి తేడా ఇక్కడే తెలుస్తుంది.


1. **`*args` & `**kwargs`**: తెలియని ఇన్‌పుట్స్ ని హ్యాండిల్ చేయడానికి.
2. **`/` & `*`**: స్ట్రిక్ట్ రూల్స్ పెట్టడానికి.
3. **Mutable Defaults**: ఆ తప్పు మళ్ళీ చేయకుండా ఉండటానికి.


ఇవి వస్తే మీరు ఏ పైథాన్ లైబ్రరీ కోడ్ నైనా సులభంగా అర్థం చేసుకోగలరు.

