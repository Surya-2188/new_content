


# పనితనం పెరగడం అంటే ఒక "Function" నేర్చుకోవడమే!


మనం ఇప్పటిదాకా చెప్పుకున్నవన్నీ ఒక్కసారి గుర్తుచేసుకుందాం. లెర్నింగ్ అంటే:
1. ఒక పని (**Task T**) చేయడం.
2. ఆ పనిలో మన పనితనం (**Performance P**) మెరుగుపడటం.
3. అనుభవం (**Experience E**) ద్వారా ఇది సాధ్యమవ్వడం.


కానీ, అసలు మెరుగుపడటం (Improvement) అంటే మెషిన్ లోపల ఏం జరుగుతుంది? దీనికి **Tom Mitchell** ఒక అద్భుతమైన ఆన్సర్ ఇచ్చారు:


> **"ఏదైనా పనిలో ఇంప్రూవ్ అవ్వడం అంటే... మ్యాథమేటికల్ గా ఒక ఫంక్షన్ (Function) ని నేర్చుకోవడమే."**


బిగినర్స్ కి ఇది కొంచెం కన్ఫ్యూజింగ్‌గా ఉండొచ్చు. దీన్ని సింపుల్ గా విడదీద్దాం.


## అసలు "Expertise" అంటే ఒక Function మాత్రమే!


మనం "చెకప్ చేయడం నేర్చుకో", "డ్రైవింగ్ నేర్చుకో" అన్నప్పుడు... మనం మ్యాజిక్ చేయమని అడగట్లేదు. మనం అడిగేది ఒక్కటే: **"పరిస్థితిని బట్టి సరైన నిర్ణయం తీసుకోవడం."**


మ్యాథ్స్ భాషలో చెప్పాలంటే, ఇన్పుట్ (Input) తీసుకుని అవుట్‌పుట్ (Output) ఇచ్చేదాన్నే **Function** అంటారు.






* **చెస్ ప్లేయర్:** బోర్డ్ ని చూసి (Input) $\rightarrow$ బెస్ట్ మూవ్ వేస్తాడు (Output).
* **డాక్టర్:** లక్షణాలు చూసి (Input) $\rightarrow$ జబ్బుని కనిపెడతాడు (Output).
* **డ్రైవర్:** రోడ్డుని చూసి (Input) $\rightarrow$ స్టీరింగ్ తిప్పుతాడు (Output).


ప్రతి ఎక్స్‌పర్ట్ చేసేది ఇదే: **"f(Situation) $\rightarrow$ Decision"**.


## మనిషి vs మెషిన్


మనుషులకి ఈ "Function" మైండ్‌లో ఆటోమేటిక్‌గా రన్ అయిపోతుంది. "నేను ఇప్పుడు మ్యాథ్స్ చేస్తున్నాను" అని మనకు అనిపించదు. అది అంతర్లీనంగా (Subconscious) జరిగిపోతుంది.


కానీ మెషిన్స్‌కి సబ్‌కాన్షియస్ ఉండదు. కాబట్టి వాటికి మనం **Explicit** గా (కచ్చితంగా) ఈ ఫంక్షన్‌ని నేర్పించాలి.


## అసలైన టార్గెట్: ChooseMove Function


మన చెస్/చెక్కిర్స్ గేమ్ విషయానికి వస్తే, మనం నేర్చుకోవాల్సిన ఫంక్షన్ పేరు **ChooseMove**.


> **ChooseMove : Board $\rightarrow$ Move**


అంటే, బోర్డ్ పొజిషన్ ఇస్తే చాలు, అది బెస్ట్ మూవ్ (Move) ఇస్తుంది.
ఒకవేళ మన దగ్గర పర్ఫెక్ట్ `ChooseMove` ఫంక్షన్ ఉంటే, ఇక మనం ఆడిన ప్రతి గేమ్ గెలిచినట్టే. ప్రపంచంలో బెస్ట్ ప్లేయర్ మనమే అవుతాం.


కానీ ఇక్కడే ఒక చిక్కు ఉంది. మనం `ChooseMove` ని నేరుగా నేర్చుకోలేం. ఎందుకో నెక్స్ట్ సెక్షన్‌లో చూద్దాం.


---


## Scalar (Continuous) Values ఎందుకు బెటర్?


### Discrete Learning లో ఉన్న కష్టం


`ChooseMove` అనేది డైరెక్ట్ గా "ఏ మూవ్ వేయాలి?" అని చెప్తుంది కదా, మరి అది ఎందుకు వద్దు?
ఎందుకంటే మూవ్స్ అనేవి **Discrete** (విడివిడిగా ఉంటాయి).


చెస్ లో మీరు గుర్రాన్ని (Knight) కదుపుతారు, లేదా కదపరు. అంతేగానీ "కొంచెం గుర్రాన్ని కదుపుతాను" అనలేరు కదా?
దీని వల్ల మెషిన్ నేర్చుకోవడం కష్టమవుతుంది. చిన్న చిన్న మార్పులని అది గుర్తించలేదు.


ఇది అర్థం చేసుకోవడానికి ఒక **డాక్టర్ ఉదాహరణ (Medical Analogy)** చూద్దాం.


## Analogy: పేషెంట్ కి ట్రీట్మెంట్ (Discrete vs Continuous)


ఒక డాక్టర్ సీరియస్ గా ఉన్న పేషెంట్ ని కాపాడాలి అనుకుందాం.


### Scenario 1: రిజల్ట్ మాత్రమే తెలిస్తే (Discrete)
డాక్టర్ మందు ఇచ్చిన తర్వాత, మెషిన్ కేవలం మూడు ముక్కలే చెప్తుంది అనుకోండి:
1. **బ్రతికి ఉన్నాడు (Alive)**
2. **సీరియస్ గా ఉన్నాడు (Worse)**
3. **చనిపోయాడు (Dead)**


ఇవి Discrete (విడివిడి) స్టేట్స్.
**సమస్య:** డాక్టర్ కి ట్రీట్మెంట్ పనిచేస్తుందో లేదో తెలియదు. పేషెంట్ పరిస్థితి కొంచెం మెరుగుపడినా, మెషిన్ "Alive" అనే చూపిస్తుంది. ఉన్నట్టుండి "Dead" అని చూపిస్తే అప్పుడు రియలైజ్ అయి లాభం లేదు. తప్పుని సరిదిద్దుకునే ఛాన్స్ ఇక్కడ ఉండదు.


### Scenario 2: నంబర్స్ తెలిస్తే (Continuous / Scalar)
ఇప్పుడు డాక్టర్ కి మానిటర్ లో నంబర్స్ కనిపిస్తున్నాయి అనుకోండి:
* **BP:** 120/80 $\rightarrow$ 118/78 (తగ్గుతోంది)
* **Pulse:** 72 $\rightarrow$ 80
* **Oxygen:** 98% $\rightarrow$ 96%


ఇవి **Continuous** (మారే విలువలు).
**ఫలితం:** చిన్న మార్పు కనిపించినా డాక్టర్ అలర్ట్ అవుతాడు. "ఓహో, బిపి కొంచెం తగ్గుతోంది, డోస్ మారుద్దాం" అని నిర్ణయం తీసుకుంటాడు. పేషెంట్ సీరియస్ అవ్వకముందే కాపాడగలడు.






**Continuous Values (నంబర్స్) మనకు క్లియర్ ఫీడ్‌బ్యాక్ ఇస్తాయి.**


## మెషిన్ లెర్నింగ్ కి లింక్ ఏంటి?


చెస్ లో కూడా అంతే:
* **Win / Lose** అనేది "Alive / Dead" లాంటిది. దీని వల్ల మెషిన్ కి ఏం నేర్చుకోవాలో అర్థం కాదు.
* **Evaluation Score (+2.5, -0.5)** అనేది "BP / Pulse" లాంటిది.


మనం బోర్డ్ పొజిషన్ కి ఒక నంబర్ (Score) ఇస్తే, మెషిన్ ఈజీగా నేర్చుకుంటుంది.
* "నిన్న నా స్కోర్ +0.2, ఈ రోజు +0.5. అంటే నేను ఇంప్రూవ్ అయ్యాను!" అని దానికి అర్థమవుతుంది.


అందుకే మనం `ChooseMove` ని వదిలేసి, **Evaluation Function (V)** ని నేర్చుకుంటాం.
> **Target Function V : Board $\rightarrow$ Real Number (Score)**


---


## Scoring Scheme: ఆ స్కోర్స్ ఎలా ఇవ్వాలి?


### The Core Rule: ఆర్డర్ ముఖ్యం, నంబర్ కాదు


మంచి పొజిషన్ కి +10 ఇవ్వొచ్చు, లేదా +1000 ఇవ్వొచ్చు. చెడ్డ పొజిషన్ కి -5 ఇవ్వొచ్చు, లేదా -500 ఇవ్వొచ్చు.
ఏ నంబర్ వాడతాం అనేది మన ఇష్టం. కానీ ఒక రూల్ మాత్రం బ్రేక్ చేయకూడదు:


> **మంచి పొజిషన్ స్కోర్ ఎప్పుడూ చెడ్డ పొజిషన్ స్కోర్ కంటే ఎక్కువ ఉండాలి.**


ఈ **Ordering** (వరుస క్రమం) సరిగ్గా ఉంటే చాలు, మెషిన్ ఆటోమేటిక్ గా మంచి దారిని ఎంచుకుంటుంది.


## Tom Mitchell గారి స్టాండర్డ్ డెఫినిషన్


మనం డిజైన్ చేసే సిస్టమ్ కోసం, Tom Mitchell ఒక స్టాండర్డ్ పద్ధతిని ఇచ్చారు. దీన్నే మనం ఫాలో అవుదాం.
మన టార్గెట్ ఫంక్షన్ **V(b)** విలువలు ఇలా ఉండాలి:


1. **If b is a Winning State (గెలిచాం):** Score = +100
2. **If b is a Losing State (ఓడిపోయాం):** Score = -100
3. **If b is a Draw State (డ్రా):** Score = 0
4. **If the game is still going (గేమ్ మధ్యలో ఉంటే):**
   $$V(b) = V(b')$$
   *(ఇక్కడ b' అంటే... మనం పర్ఫెక్ట్ గా ఆడితే చివర్లో వచ్చే రిజల్ట్)*


### Recursive Rule (V(b) = V(b')) అంటే ఏంటి?
సింపుల్ గా చెప్పాలంటే: **"భవిష్యత్తులో రాబోయే ఫలితమే, ఇప్పటి మన స్కోర్."**
మీరు ఇప్పుడున్న పొజిషన్ నుంచి, కచ్చితంగా గెలిచే దారిలో ఉంటే... మీ ప్రస్తుత స్కోర్ కూడా +100 అన్నమాట.


## అసలు సమస్య: ఇది లెక్కించడం అసాధ్యం (Non-Operational)


ఈ డెఫినిషన్ వినడానికి బాగుంది కానీ, ప్రాక్టికల్ గా పనికిరాదు.
ఎందుకంటే, గేమ్ మధ్యలో ఉండి "చివరికి ఏం జరుగుతుంది?" అని తెలుసుకోవాలంటే, కంప్యూటర్ కోటానుకోట్ల మూవ్స్ ని చెక్ చేయాలి. అది అసాధ్యం. దీన్నే **Non-Operational** అంటారు.


## పరిష్కారం: Function Approximation (అంచనా వేయడం)


మనం పర్ఫెక్ట్ **V(b)** ని కనుక్కోలేం కాబట్టి, దాన్ని **అంచనా (Approximation)** వేస్తాం. దాన్నే $\hat{V}$ (V-hat) అంటాం.


> **Target: $\hat{V}(b) \approx V(b)$**


మన గోల్ ఏంటంటే:
1. ఈ $\hat{V}$ ని **క్షణాల్లో** లెక్కపెట్టగలగాలి.
2. అది ఇచ్చే స్కోర్, నిజమైన స్కోర్ కి **చాలా దగ్గరగా** ఉండాలి.


ఇప్పుడు అసలు ప్రశ్న: **"మరి బోర్డ్ ని చూడగానే స్కోర్ ఎలా వేస్తాం? బోర్డ్ లో ఏమేం చూడాలి?"**


దీని గురించే నెక్స్ట్ సెక్షన్: **1.4 Choosing the Representation (బోర్డ్ ని ఎలా రిప్రజెంట్ చేయాలి?)**


***


